import { isFile } from '../../lib/fs.js';
import { generateKeypair } from '../../lib/auth/keypair.js';
import { existsSync, readFileSync } from 'fs';
import { highlight, note } from '../../lib/logger.js';
import { v4 as uuidv4 } from 'uuid';
import { input, select, password, checkbox } from '@inquirer/prompts';
import { Flags } from '@oclif/core';
import Command from '../../lib/command.js';

export default class ServiceAccountCreate extends Command {
	static override aliases = [
		'service-account:add',
		'service-account:new'
	];

	static override summary = 'Create a service account.';

	static override description = `A service account requires a name and either a
client secret key or a PEM formatted public key.

The service account's client id is autogenerated by the platform based on the
provided name.

If the service account name is not specified, then the command will
interactively prompt for all values. If prompting is not available, then all
required options must be passed in at execution.`;

	static override flags = {
		desc: Flags.string({
			description: 'The description of the service account.'
		}),
		name: Flags.string({
			description: 'Friendly name to use for display.'
		}),
		org: Flags.string({
			description: 'The organization name, id, or guid; defaults to the current org.'
		}),
		'public-key': Flags.string({
			description: 'The path to the public key.'
		}),
		role: Flags.string({
			description: 'Assign one or more organization roles to the service account.',
			multiple: true
		}),
		secret: Flags.string({
			description: 'A custom client secret key.'
		})
	};

	static override examples = [
		{
			description: 'Create a service account and prompt for name, type, etc',
			command: '<%= config.bin %> <%= command.id %>'
		},
		{
			description: 'Create a service account with a auto-generated client secret key',
			command: '<%= config.bin %> <%= command.id %> --name foo'
		},
		{
			description: 'Create a service account with a custom client secret key',
			command: '<%= config.bin %> <%= command.id %> --name foo --secret bar'
		},
		{
			description: 'Create a service account with a PEM formatted public key',
			command: '<%= config.bin %> <%= command.id %> --name foo --public-key /path/to/public_key.pem'
		}
	];

	static override enableJsonFlag = true;

	async run(): Promise<any> {
		const { flags, account, org, sdk } = await this.parse(ServiceAccountCreate);

		if (!account.user.roles.includes('administrator')) {
			throw new Error(`You do not have administrative access to create a service account in the "${org.name}" organization`);
		}

		if (!this.jsonEnabled()) {
			this.log(`Account:      ${highlight(account.name)}`);
			this.log(`Organization: ${highlight(org.name)} ${note(`(${org.guid})`)}\n`);
		}

		let {
			desc,
			name,
			'public-key': publicKey,
			role: roles = [],
			secret
		} = flags;
		let prompted = false;
		const doPrompt = async (opts: any) => {
			prompted = true;
			if (opts.type === 'input') {
				return input({
					message: opts.message,
					default: opts.initial,
					validate: opts.validate
				});
			} else if (opts.type === 'select') {
				return select({
					message: opts.message,
					choices: opts.choices,
					default: opts.initial
				});
			} else if (opts.type === 'password') {
				return password({
					message: opts.message,
					validate: opts.validate
				});
			} else if (opts.type === 'checkbox') {
				return checkbox({
					message: opts.message,
					choices: opts.choices
				});
			}
			throw new Error('Unsupported prompt type');
		};

		if (!name) {
			if (!process.stdin.isTTY) {
				return this.help();
			}

			name = await doPrompt({
				hint: 'A friendly name used for display',
				message: 'Display name',
				type: 'input',
				validate(s: string) {
					return s ? true : 'Please enter a service account name';
				}
			});
		}

		if (!desc && !flags.name) {
			desc = await doPrompt({
				message: `Description ${note('(optional)')}`,
				type: 'input'
			});
		}

		if (!secret && !publicKey) {
			if (!process.stdin.isTTY) {
				throw new Error('Missing required --secret <key> or --public-key <path>');
			}

			const type = await doPrompt({
				message: 'Authentication method',
				type: 'select',
				choices: [
					{ name: 'Auto-generated client secret key', value: 'auto' },
					{ name: 'Custom client secret key', value: 'secret' },
					{ name: 'Specify PEM formatted public key file', value: 'publicKey' },
					{ name: 'Generate a new public/private key pair', value: 'generate' }
				]
			});

			if (type === 'auto') {
				secret = uuidv4();
			} else if (type === 'secret') {
				secret = await doPrompt({
					message: 'Secret key',
					type: 'password',
					validate(s: string) {
						return s ? true : 'Please enter a client secret key';
					}
				});
			} else if (type === 'publicKey') {
				publicKey = await doPrompt({
					message: 'Public key file path',
					type: 'input',
					validate(s: string) {
						if (!s) {
							return 'Please enter the path to the PEM formatted public key file';
						}
						if (!isFile(s)) {
							return 'Specified file does not exist';
						}
						if (!readFileSync(s, 'utf-8').startsWith('-----BEGIN PUBLIC KEY-----')) {
							return 'Specified file is not in the PEM format';
						}
						return true;
					}
				});
			} else if (type === 'generate') {
				const certs = await generateKeypair({
					silent: this.jsonEnabled() || !process.stdin.isTTY
				}) as any;

				publicKey = certs.publicKey.file;
			}
		}

		if (!roles.length && !flags.name) {
			const availableRoles = await sdk.role.list(account, { org });
			roles = await doPrompt({
				choices: availableRoles.map((role: any) => ({ name: role.name, value: role.id })),
				message: 'Roles',
				type: 'checkbox'
			});
		}

		if (publicKey) {
			if (!existsSync(publicKey)) {
				throw new Error(`Public key ${publicKey} does not exist`);
			}
			if (!isFile(publicKey)) {
				throw new Error(`Public key ${publicKey} is not a file`);
			}
			const publicKeyFile = publicKey;
			publicKey = readFileSync(publicKeyFile, 'utf-8');
			if (!publicKey.startsWith('-----BEGIN PUBLIC KEY-----')) {
				throw new Error(`Public key ${publicKeyFile} is not a PKCS#8 PEM formatted file`);
			}
		}

		const results = await sdk.client.create(account, org, {
			desc,
			name,
			publicKey,
			secret,
			roles
		});

		if (this.jsonEnabled()) {
			results.client.secret = secret;
			return {
				account,
				...results
			};
		} else {
			if (prompted) {
				this.log();
			}

			const { client_id } = results.client;
			this.log('Successfully created service account\n');

			if (secret) {
				this.log(`Client ID:         ${highlight(client_id)}`);
				this.log(`Client Secret Key: ${highlight(secret)}\n`);
				this.log('Please record the secret key in a safe place.');
			} else {
				this.log(`Client ID: ${highlight(client_id)}`);
			}
		}
	}
}
